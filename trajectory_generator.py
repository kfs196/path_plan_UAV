"""
In this file, you should implement your trajectory generation class or function.
Your method must generate a smooth 3-axis trajectory (x(t), y(t), z(t)) that 
passes through all the previously computed path points. A positional deviation 
up to 0.1 m from each path point is allowed.

You should output the generated trajectory and visualize it. The figure must
contain three subplots showing x, y, and z, respectively, with time t (in seconds)
as the horizontal axis. Additionally, you must plot the original discrete path 
points on the same figure for comparison.

You are expected to write the implementation yourself. Do NOT copy or reuse any 
existing trajectory generation code from others. Avoid using external packages 
beyond general scientific libraries such as numpy, math, or scipy. If you decide 
to use additional packages, you must clearly explain the reason in your report.
"""

import numpy as np
from scipy.linalg import solve
import matplotlib.pyplot as plt

config = {'font.family':'Times New Roman'}
plt.rcParams.update(config)
plt.rcParams['axes.unicode_minus'] =False


class TrajectoryGenerator:

    def __init__(self, path_points:np.ndarray, ref_vel:float):
        """
        Initialize the trajectory generator with the path points.

        Parameters:
            path_points (list): A list of path points [(x1, y1, z1), (x2, y2, z2), ...], unit are meter.
            ref_vel (float): The expected average velocity of the trajectory.
        """
        self.path_points = path_points
        self.ref_vel = ref_vel

        self.tradj_dict = dict({})
        '''traj_dict (dict): {'X-coeff': np.ndarray, 'Y-coeff': np.ndarray, 'Z-coeff': np.ndarray, time_points: np.ndarray}'''
    
    def TrajectorySolve(self):
        '''
        After initializing the trajectory generator, use this function to solve the minimization problem of acceleration.\n
        The result of this function is stored in the `self.tradj_dict` variable.  
        ''' 

        path_points_check = np.asarray(self.path_points, dtype=float)
        if path_points_check.ndim != 2 or path_points_check.shape[1] != 3: # Check if path_points is a 2D array and each row has 3 columns
            raise ValueError("Error: path_points must be of shape (N, 3)")
        
        seg_distance = [np.linalg.norm(path_points_check[i, :] - path_points_check[i+1, :]) for i in range(len(path_points_check)-1)] # Calculate the distance between each two path points
        
        time_seg = np.array(seg_distance) / self.ref_vel # Allocate time based on Euclidean distance

        if len(time_seg) != (path_points_check.shape[0] - 1) : # Check if the number of time segments is equal to the number of path points - 1
            raise ValueError("Error: The number of time segments must be equal to the number of path points - 1")
        
        traj_dict = dict({})
        
        print("*** Start solving the Optimized Trajectory ***")
        
        for i, key in enumerate(['X-coeff', 'Y-coeff',  'Z-coeff']): 

            ans = self.SolveMinAccel(path_points_check[:,i], time_seg)
            print(f"** Finished solving: {key} **")
            traj_dict[key] = ans

        time_points = np.zeros(path_points_check.shape[0])

        for i in range(path_points_check.shape[0]): # transform time seg to time points
            if i == 0:
                time_points[i] = 0
            else:
                time_points[i] = np.sum(time_seg[:i])

        traj_dict['time_points'] = time_points

        self.tradj_dict =  traj_dict  


    def PlotTrajectory(self, time_dense:int = 0.1):
        """
        Plot the trajectory generated by the `TrajectorySolve` function.

        Parameters:
            time_dense (int): How often should a point be plotted (in seconds)
        """  

        traj_dict_plot = dict({'x': [], 'y': [], 'z': []})

        if self.tradj_dict is None:
            raise ValueError("Error: Please run TrajectorySolve() first")

        time_points = self.tradj_dict['time_points'] # read variables from dict
        coeff_x = self.tradj_dict['X-coeff'] 
        coeff_y = self.tradj_dict['Y-coeff']
        coeff_z = self.tradj_dict['Z-coeff']

        total_time = time_points[-1] # get total time
        time_series = np.arange(0, total_time, time_dense)

        if time_series[-1] < total_time:
            time_series = np.append(time_series, total_time) # Include the last time point

        for ti in time_series: # search where the time point is in the time series

            idx = np.searchsorted(time_points, ti, side='right')-1 # Find the index to properly interpolate
            if idx >= len(time_points)-1: # Process the special case of the last time point
                idx = len(time_points)-2 # Avoid out of bound
            if idx < 0: # Process the special case of the first time point
                idx = 0
            t_start = time_points[idx]
            t_local = ti - t_start # calculate local time of a segment
            base = idx * 6
        
            axis_keys = ['x', 'y', 'z']
            for axis in axis_keys: # get the polynomial coefficients by position
                co = np.array([])
                if axis == 'x':
                    co = coeff_x[base : base+6]
                elif axis == 'y':
                    co = coeff_y[base : base+6]
                elif axis == 'z':
                    co = coeff_z[base : base+6]
                val = co[0] + co[1]*t_local + co[2]*t_local**2 + \
                co[3]*t_local**3 + co[4]*t_local**4 + co[5]*t_local**5 # Calculate the the value by local time
                traj_dict_plot[axis].append(val)

        fig, axes = plt.subplots(3, 1, figsize=(9, 9), sharex=True) # Start visualization     
        labels = ['X Position (m)', 'Y Position (m)', 'Z Position (m)']

        path_arr =self.path_points # Original waypoints
        for i, ax in enumerate(axes):
            key = axis_keys[i]
            ax.plot(time_series, traj_dict_plot[key], label=labels[i],
                    color='teal', lw=1.5)
            ax.scatter(time_points, path_arr[:,i], label='Waypoints',
                       color='navy', marker='o', zorder=5 )
            # ax.grid(True, linestyle='--', alpha=0.6)
            ax.legend(fontsize=12)
            
            for tp in time_points:
                ax.axvline(x=tp, color='gray', linestyle=':', alpha=0.6)    
        axes[2].set_xlabel('Time (s)')
        plt.suptitle(f'UAV Trajectory Generation (Ref Velocity: {self.ref_vel} m/s)',fontsize=14)
        plt.tight_layout()
        plt.show()


    def _QuinticAccelMat(self, T:float):
        """
        Q matrix for one quintic segment with duration T
        minimizing integral of acceleration squared

        Parameters:
            T (float): A certain time point among the path
        Returns:
            qmat (np.ndarray): A quintic integrated matrix for one segment
        """
        qmat = np.zeros((6, 6))

        qmat[2, 2] = 4 * T
        qmat[2, 3] = 6 * T**2
        qmat[2, 4] = 8 * T**3
        qmat[2, 5] = 10 * T**4
        qmat[3, 3] = 12 * T**3
        qmat[3, 4] = 18 * T**4
        qmat[3, 5] = 24 * T**5
        qmat[4, 4] = 144 / 5 * T**5
        qmat[4, 5] = 40 * T**6
        qmat[5, 5] = 400 / 7 * T**7
        
        qmat = qmat + qmat.T - np.diag(qmat.diagonal()) # build symmetric matrix
        return qmat
    

    def BuildGlobalQMat(self, T_list:np.ndarray) :
        """
        Build the global Q matrix for all quintic segments

        Parameters:
            T_list (np.ndarray): The list of time segments
        """

        Q_blocks = [self._QuinticAccelMat(T) for T in T_list] # Generate Q matrix series for each segment
        qmat = np.block([
            [Q_blocks[i] if i == j else np.zeros_like(Q_blocks[0])
            for j in range(len(Q_blocks))]
            for i in range(len(Q_blocks))
        ]) # Q matrix for diagonal and zero matrix for off-diagonal
        return qmat
    

    def _ConsRow(self, seg_iter:int, t_node:float, order:int, length:int):
        """
        Construct a row of constraint matrix for one segment

        Parameters:
            seg_iter (int): The index of segment
            t_node (float): The start or end time point of one segment
            order (int): The order of derivative
            length (int): the length of the constraint vector for one segment (= 6* len(T_list))
        Returns:
            row (np.ndarray): A row of constraint matrix
        """

        row = np.zeros(length)
        base = 6 * seg_iter

        if order == 0:  # 0-Derivative: position
            row[base:base+6] = [1, t_node, t_node**2, t_node**3, t_node**4, t_node**5]
        elif order == 1:  # 1-Derivative: velocity
            row[base:base+6] = [0, 1, 2*t_node, 3*t_node**2, 4*t_node**3, 5*t_node**4]
        elif order == 2:  # 2-Derivative: acceleration
            row[base:base+6] = [0, 0, 2, 6*t_node, 12*t_node**2, 20*t_node**3]
        else:
            raise ValueError("Error: Unsupported derivative order!")

        return row


    def BuildConstraint(self, points_1d:np.ndarray, T_list:np.ndarray):
        """
        Build the constraint matrix for all quintic segments: Aa=b \n
        Total num of constraints: 4n+2 (n is equal to  len(T_list))

        Parameters:
            points_1d (np.ndarray): A one-dimensional array of path points 
            T_list (np.ndarray): The list of time segments
        Returns:
            matA,vecB (np.ndarray): The full constraint matrix (A), and the right values of constraint matrix (b)
        """

        n_seg = len(T_list) # number of time segments
        rows = list([]) # rows of constraint matrix, each row is a 6-elements array with const coeff of a0-a5
        vals = list([]) # values of constraint matrix, b
        
        for i in range(n_seg): # Add position constraints 
            
            rows.append(self._ConsRow(i, 0, 0, 6*n_seg)) # start point
            vals.append(points_1d[i])
            rows.append(self._ConsRow(i, T_list[i], 0, 6*n_seg)) # end point
            vals.append(points_1d[i+1])

        for i in range(n_seg-1): # Add velocity and acceleration constraints (n_seg-1: avoid overflow)

            rows.append(self._ConsRow(i, T_list[i], 1, 6*n_seg) - 
                             self._ConsRow(i+1, 0, 1, 6*n_seg)) # continuous velocity
            vals.append(0.0)

            rows.append(self._ConsRow(i, T_list[i], 2, 6*n_seg) -
                             self._ConsRow(i+1, 0, 2, 6*n_seg))
            vals.append(0.0)

        rows.append(self._ConsRow(0, 0, 1, 6*n_seg)) # initial velocity = 0
        vals.append(0.0)
        rows.append(self._ConsRow(0, 0, 2, 6*n_seg)) # initial acceleration = 0
        vals.append(0.0)
        rows.append(self._ConsRow(n_seg-1, T_list[-1], 1, 6*n_seg)) # final velocity = 0
        vals.append(0.0)
        rows.append(self._ConsRow(n_seg-1, T_list[-1], 2, 6*n_seg)) # final acceleration = 0
        vals.append(0.0)

        matA = np.vstack(rows) # Constraint matrix A, size: (4n+2)*6
        vecB = np.array(vals)
        return matA, vecB
    

    def SolveMinAccel(self, points_1d:np.ndarray, T_list:np.ndarray):
        """
        Solve the minimization problem of acceleration with Runge-Kutta methods

        Parameters:
            points_1d (np.ndarray): A one-dimensional array of path points 
        Returns:
            coef_mat (np.ndarray): The coefficients matrix of quintic segments
        """

        Q = self.BuildGlobalQMat(T_list)
        A, b = self.BuildConstraint(points_1d, T_list)
        kkt_mat =np.block([
            [Q, A.T],
            [A, np.zeros((A.shape[0], A.shape[0]))]
        ]) # hight and width of KKT matrix : 6n + (4n+2)
        rhs_vec = np.block([np.zeros(Q.shape[0]), b]) # length of rhs_vec: 6n + (4n+2) 
        
        sol = np.linalg.solve(kkt_mat, rhs_vec)
        return sol[:Q.shape[0]] # return the param vector of each trajectory segment (a0-a5)
        


if __name__ == "__main__":

    # trajectory-gen test code
    uav_path = np.array([
        [0.0,   0.0,   0.0],
        [1.0,   0.2,   0.1],
        [2.0,   0.8,   0.3],
        [3.0,   1.6,   0.6],
        [4.0,   2.5,   1.0],
        [5.0,   3.3,   1.5],
        [6.0,   3.8,   2.1],
        [7.0,   4.0,   2.8],
        [8.0,   3.9,   3.6],
        [9.0,   3.5,   4.5],
        [10.0,  2.8,   5.5],
        [11.0,  2.0,   6.6],
        [12.0,  1.2,   7.8],
        [13.0,  0.6,   9.1],
        [14.0,  0.3,  10.5],
        [15.0,  0.5,  12.0],
        [16.0,  1.1,  13.6],
        [17.0,  2.1,  15.3],
        [18.0,  3.4,  17.1],
        [19.0,  5.0,  19.0]
    ])

    traj_generator = TrajectoryGenerator(uav_path, 1.0)
    traj_generator.TrajectorySolve()
    ans_dict = traj_generator.tradj_dict
    for key in ans_dict.keys():
        print(key, ":\n", ans_dict[key])

    traj_generator.PlotTrajectory(0.05)

